-- File name: core.lua
-- Author: Fro-Q
-- Created: 2025-11-03 00:41:06
-- Last modified: 2025-11-03 16:49:12
-- ------
-- headup.nvim core functionality
--]]

---@mod headup.core Core of headup.nvim
--- Autocmds, scanning and buffer updates.

---@diagnostic disable: undefined-global
require("headup.types")
local utils = require("headup.utils")
local Core = {}

-- Global state
local config = {}
local original_content = {} -- Store original matched content for each buffer
local autocmd_groups = {}   -- Store autocmd group IDs

--- Initialize core with parsed config and activate if enabled
---@param user_config table
Core.setup = function(user_config)
  config = user_config

  if config.enabled then
  Core.enable()
  end
end

-- no-op: file patterns are provided directly by config

--- Cache the original matched content for faster change detection
--- @private
---@param bufnr number
---@param item_config table
local function cache_buffer_content(bufnr, item_config)
  -- If excluded, skip
  local filename = vim.api.nvim_buf_get_name(bufnr)
  if utils.path_matches(filename, item_config.exclude_pattern) then
    return
  end

  local lines = vim.api.nvim_buf_get_lines(bufnr, 0, item_config.max_lines or 20, false)

  -- Search for pattern match
  for i, line in ipairs(lines) do
  local match = line:match(item_config.match_pattern)
    if match then
      -- Store original content for this buffer and config
      if not original_content[bufnr] then
        original_content[bufnr] = {}
      end
      original_content[bufnr][item_config] = {
        content = match,
        line_num = i - 1, -- Convert to 0-based indexing
      }
      return
    end
    if item_config.end_pattern and line:match(item_config.end_pattern) then
      break
    end
  end

  -- If no match found, clear any stored value for this config
  if original_content[bufnr] then
    original_content[bufnr][item_config] = nil
  end
end

--- Check if user manually updated the matched content
--- @private
---@param bufnr number
---@param item_config table
---@return boolean
local function user_manually_updated(bufnr, item_config)
  local cached = original_content[bufnr] and original_content[bufnr][item_config]
  if not cached then
    return false -- No cache, assume not manually updated
  end

  local lines = vim.api.nvim_buf_get_lines(bufnr, 0, item_config.max_lines or 20, false)

  -- Find current content
  for _, line in ipairs(lines) do
    local match = line:match(item_config.match_pattern)
    if match then
      -- Compare with cached content
      return cached.content ~= match
    end
    if item_config.end_pattern and line:match(item_config.end_pattern) then
      break
    end
  end

  return false -- Pattern not found, assume not manually updated
end

--- Generate new content based on content type
--- @private
---@param content string
---@param time_format string|'inherit'
---@param old_content string|nil
---@param bufnr number
---@return string
local function generate_new_content(content, time_format, old_content, bufnr)
  if content == "current_time" then
    local format = time_format
    if format == "inherit" and old_content then
      local detected = utils.detect_time_format(old_content)
      if detected then
        format = detected
      end
    end
    if format == "inherit" or not format then
      format = "%Y-%m-%d %H:%M:%S" -- Default format
    end
    return tostring(os.date(format))
  elseif content == "file_size" then
    return utils.get_file_size(bufnr)
  elseif content == "line_count" then
    return tostring(vim.api.nvim_buf_line_count(bufnr))
  elseif content == "file_name" then
    local name = vim.api.nvim_buf_get_name(bufnr)
    return name:match("[^/\\]+$") or name
  elseif content == "file_path_abs" then
    return vim.api.nvim_buf_get_name(bufnr)
  elseif content == "file_path" then
    local abs = vim.api.nvim_buf_get_name(bufnr)
    -- local cwd = vim.loop.cwd()
    local cwd = vim.fn.getcwd()
    if cwd and abs:sub(1, #cwd) == cwd then
      local rel = abs:sub(#cwd + 2)
      return rel ~= "" and rel or abs
    end
    return abs
  else
    vim.notify("headup.nvim: Unknown content: " .. tostring(content), vim.log.levels.ERROR)
    return old_content or ""
  end
end

--- Update content in buffer (single config item)
--- @private
---@param bufnr number
---@param item_config table
local function update_buffer_content(bufnr, item_config)
  -- Only update if buffer has been modified
  if not vim.api.nvim_get_option_value("modified", { buf = bufnr }) then
    return
  end

  local lines = vim.api.nvim_buf_get_lines(bufnr, 0, item_config.max_lines or 20, false)

  -- Find the line with match_pattern
  for i, line in ipairs(lines) do
    local match = line:match(item_config.match_pattern)
    if match then
      -- Check if user manually updated
      if user_manually_updated(bufnr, item_config) then
        if not config.silent then
          vim.notify("headup.nvim: Skipping automatic update due to manual change", vim.log.levels.INFO)
        end
        -- Update cache with new manual value
        cache_buffer_content(bufnr, item_config)
        return
      end

      -- Generate new content
      local new_content = generate_new_content(
        item_config.content,
        item_config.time_format or "inherit",
        match,
        bufnr
      )

      -- Update the line using string substitution
      local updated_line = line:gsub(utils.escape_pattern(match), new_content)

      -- Only update if content actually changed
      if updated_line ~= line then
        -- Get all lines to update the specific line
        local all_lines = vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)
        all_lines[i] = updated_line
        vim.api.nvim_buf_set_lines(bufnr, 0, -1, false, all_lines)

        -- Show notification if not silent
        if not config.silent then
          local content_name = utils and utils.format_content_name and
              utils.format_content_name(item_config.content) or item_config.content
          vim.notify("headup.nvim: Auto-updated " .. content_name .. " to: " .. new_content, vim.log.levels.INFO)
        end

        -- Update cache
        cache_buffer_content(bufnr, item_config)
      end

      return
    end
    if item_config.end_pattern and line:match(item_config.end_pattern) then
      break
    end
  end
end

--- Enable autocmds for all configured patterns
Core.enable = function()
  -- Clear existing autocommands
  Core.disable()

  -- Create autocommands for each config
  for i, item_config in ipairs(config.configs) do
    local patterns = item_config.pattern
    if type(patterns) == "string" then
      patterns = { patterns }
    end

    for _, pat in ipairs(patterns) do
      local group_name = "HeadupNvim_" .. i .. "_" .. pat:gsub("[^%w]", "_")

      -- Create autocommand group
      local group = vim.api.nvim_create_augroup(group_name, { clear = true })
      table.insert(autocmd_groups, group)

      -- Cache content when file is opened or saved
      vim.api.nvim_create_autocmd({ "BufReadPost", "BufWritePost" }, {
        group = group,
        pattern = pat,
        callback = function(args)
          local fname = vim.api.nvim_buf_get_name(args.buf)
          if utils.path_matches(fname, item_config.exclude_pattern) then
            return
          end
          cache_buffer_content(args.buf, item_config)
        end,
      })

      -- Update content before saving
      vim.api.nvim_create_autocmd("BufWritePre", {
        group = group,
        pattern = pat,
        callback = function(args)
          local fname = vim.api.nvim_buf_get_name(args.buf)
          if utils.path_matches(fname, item_config.exclude_pattern) then
            return
          end
          update_buffer_content(args.buf, item_config)
        end,
      })
    end
  end
end

--- Disable all autocmds created by this module
Core.disable = function()
  -- Clear all autocmd groups
  for _, group in ipairs(autocmd_groups) do
    vim.api.nvim_clear_autocmds({ group = group })
  end
  autocmd_groups = {}
end

--- Manually update current buffer by applying all matching item configs
---@param bufnr number
Core.update_buffer = function(bufnr)
  local filename = vim.api.nvim_buf_get_name(bufnr)
  local updated = false

  -- Find matching configurations
  for _, item_config in ipairs(config.configs) do
    if utils.path_matches(filename, item_config.pattern) and not utils.path_matches(filename, item_config.exclude_pattern) then
        local lines = vim.api.nvim_buf_get_lines(bufnr, 0, item_config.max_lines or 20, false)

        -- Find and update pattern
        for i, line in ipairs(lines) do
          local match = line:match(item_config.match_pattern)
          if match then
            local new_content = generate_new_content(
              item_config.content,
              item_config.time_format or "inherit",
              match,
              bufnr
            )

            local updated_line = line:gsub(utils.escape_pattern(match), new_content)

            if updated_line ~= line then
              local all_lines = vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)
              all_lines[i] = updated_line
              vim.api.nvim_buf_set_lines(bufnr, 0, -1, false, all_lines)

              if not config.silent then
                local content_name = utils and utils.format_content_name and
                    utils.format_content_name(item_config.content) or item_config.content
                vim.notify("headup.nvim: Updated " .. content_name .. " to: " .. new_content, vim.log.levels.INFO)
              end

              cache_buffer_content(bufnr, item_config)
              updated = true
            end
            break
          end
          if item_config.end_pattern and line:match(item_config.end_pattern) then
            break
          end
        end
    end
  end

  if not updated then
    vim.notify("headup.nvim: No matching pattern found in current buffer", vim.log.levels.WARN)
  end
end

--- Clear in-memory caches
Core.clear_cache = function()
  original_content = {}
end

return Core
